{"remainingRequest":"C:\\laragon\\www\\hym\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\laragon\\www\\hym\\node_modules\\qz-tray\\qz-tray.js","dependencies":[{"path":"C:\\laragon\\www\\hym\\node_modules\\qz-tray\\qz-tray.js","mtime":1598548665649},{"path":"C:\\laragon\\www\\hym\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1598548657832},{"path":"C:\\laragon\\www\\hym\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1598548652833}],"contextDependencies":[],"result":["'use strict';\r\n\r\n/**\r\n * @version 2.0.10;\r\n * @overview QZ Tray Connector\r\n * <p/>\r\n * Connects a web client to the QZ Tray software.\r\n * Enables printing and device communication from javascript.\r\n *\r\n * @requires RSVP\r\n *     Provides Promises/A+ functionality for API calls.\r\n *     Can be overridden via <code>qz.api.setPromiseType</code> to remove dependency.\r\n * @requires Sha256\r\n *     Provides hashing algorithm for signing messages.\r\n *     Can be overridden via <code>qz.api.setSha256Type</code> to remove dependency.\r\n */\r\nvar qz = (function() {\r\n\r\n///// POLYFILLS /////\r\n\r\n    if (!Array.isArray) {\r\n        Array.isArray = function(arg) {\r\n            return Object.prototype.toString.call(arg) === '[object Array]';\r\n        };\r\n    }\r\n\r\n\r\n///// PRIVATE METHODS /////\r\n\r\n    var _qz = {\r\n        VERSION: \"2.0.10\",                              //must match @version above\r\n        DEBUG: false,\r\n\r\n        log: {\r\n            /** Debugging messages */\r\n            trace: function() { if (_qz.DEBUG) { console.log.apply(console, arguments); } },\r\n            /** General messages */\r\n            info: function() { console.info.apply(console, arguments); },\r\n            /** Debugging errors */\r\n            warn: function() { if (_qz.DEBUG) { console.warn.apply(console, arguments); } },\r\n            /** General errors */\r\n            error: function() { console.error.apply(console, arguments); }\r\n        },\r\n\r\n\r\n        //stream types\r\n        streams: {\r\n            serial: 'SERIAL', usb: 'USB', hid: 'HID'\r\n        },\r\n\r\n\r\n        websocket: {\r\n            /** The actual websocket object managing the connection. */\r\n            connection: null,\r\n\r\n            /** Default parameters used on new connections. Override values using options parameter on {@link qz.websocket.connect}. */\r\n            connectConfig: {\r\n                host: [\"localhost\", \"localhost.qz.io\"], //hosts QZ Tray can be running on\r\n                hostIndex: 0,                           //internal var - index on host array\r\n                usingSecure: true,                      //boolean use of secure protocol\r\n                protocol: {\r\n                    secure: \"wss://\",                   //secure websocket\r\n                    insecure: \"ws://\"                   //insecure websocket\r\n                },\r\n                port: {\r\n                    secure: [8181, 8282, 8383, 8484],   //list of secure ports QZ Tray could be listening on\r\n                    insecure: [8182, 8283, 8384, 8485], //list of insecure ports QZ Tray could be listening on\r\n                    portIndex: 0                        //internal var - index on active port array\r\n                },\r\n                keepAlive: 60,                          //time between pings to keep connection alive, in seconds\r\n                retries: 0,                             //number of times to reconnect before failing\r\n                delay: 0                                //seconds before firing a connection\r\n            },\r\n\r\n            setup: {\r\n                /** Loop through possible ports to open connection, sets web socket calls that will settle the promise. */\r\n                findConnection: function(config, resolve, reject) {\r\n                    //force flag if missing ports\r\n                    if (!config.port.secure.length) {\r\n                        if (!config.port.insecure.length) {\r\n                            reject(new Error(\"No ports have been specified to connect over\"));\r\n                            return;\r\n                        } else if (config.usingSecure) {\r\n                            _qz.log.error(\"No secure ports specified - forcing insecure connection\");\r\n                            config.usingSecure = false;\r\n                        }\r\n                    } else if (!config.port.insecure.length && !config.usingSecure) {\r\n                        _qz.log.trace(\"No insecure ports specified - forcing secure connection\");\r\n                        config.usingSecure = true;\r\n                    }\r\n\r\n                    var deeper = function() {\r\n                        config.port.portIndex++;\r\n\r\n                        if ((config.usingSecure && config.port.portIndex >= config.port.secure.length)\r\n                            || (!config.usingSecure && config.port.portIndex >= config.port.insecure.length)) {\r\n                            if (config.hostIndex >= config.host.length - 1) {\r\n                                //give up, all hope is lost\r\n                                reject(new Error(\"Unable to establish connection with QZ\"));\r\n                                return;\r\n                            } else {\r\n                                config.hostIndex++;\r\n                                config.port.portIndex = 0;\r\n                            }\r\n                        }\r\n\r\n                        // recursive call until connection established or all ports are exhausted\r\n                        _qz.websocket.setup.findConnection(config, resolve, reject);\r\n                    };\r\n\r\n                    var address;\r\n                    if (config.usingSecure) {\r\n                        address = config.protocol.secure + config.host[config.hostIndex] + \":\" + config.port.secure[config.port.portIndex];\r\n                    } else {\r\n                        address = config.protocol.insecure + config.host[config.hostIndex] + \":\" + config.port.insecure[config.port.portIndex];\r\n                    }\r\n\r\n                    try {\r\n                        _qz.log.trace(\"Attempting connection\", address);\r\n                        _qz.websocket.connection = new _qz.tools.ws(address);\r\n                    }\r\n                    catch(err) {\r\n                        _qz.log.error(err);\r\n                        deeper();\r\n                        return;\r\n                    }\r\n\r\n                    if (_qz.websocket.connection != null) {\r\n                        _qz.websocket.connection.established = false;\r\n\r\n                        //called on successful connection to qz, begins setup of websocket calls and resolves connect promise after certificate is sent\r\n                        _qz.websocket.connection.onopen = function(evt) {\r\n                            if (!_qz.websocket.connection.established) {\r\n                                _qz.log.trace(evt);\r\n                                _qz.log.info(\"Established connection with QZ Tray on \" + address);\r\n\r\n                                _qz.websocket.setup.openConnection({ resolve: resolve, reject: reject });\r\n\r\n                                if (config.keepAlive > 0) {\r\n                                    var interval = setInterval(function() {\r\n                                        if (!qz.websocket.isActive()) {\r\n                                            clearInterval(interval);\r\n                                            return;\r\n                                        }\r\n\r\n                                        _qz.websocket.connection.send(\"ping\");\r\n                                    }, config.keepAlive * 1000);\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        //called during websocket close during setup\r\n                        _qz.websocket.connection.onclose = function() {\r\n                            // Safari compatibility fix to raise error event\r\n                            if (_qz.websocket.connection && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {\r\n                                _qz.websocket.connection.onerror();\r\n                            }\r\n                        };\r\n\r\n                        //called for errors during setup (such as invalid ports), reject connect promise only if all ports have been tried\r\n                        _qz.websocket.connection.onerror = function(evt) {\r\n                            _qz.log.trace(evt);\r\n\r\n                            _qz.websocket.connection = null;\r\n\r\n                            deeper();\r\n                        };\r\n                    } else {\r\n                        reject(new Error(\"Unable to create a websocket connection\"));\r\n                    }\r\n                },\r\n\r\n                /** Finish setting calls on successful connection, sets web socket calls that won't settle the promise. */\r\n                openConnection: function(openPromise) {\r\n                    _qz.websocket.connection.established = true;\r\n\r\n                    //called when an open connection is closed\r\n                    _qz.websocket.connection.onclose = function(evt) {\r\n                        _qz.log.trace(evt);\r\n                        _qz.log.info(\"Closed connection with QZ Tray\");\r\n\r\n                        //if this is set, then an explicit close call was made\r\n                        if (_qz.websocket.connection.promise != undefined) {\r\n                            _qz.websocket.connection.promise.resolve();\r\n                        }\r\n\r\n                        _qz.websocket.callClose(evt);\r\n                        _qz.websocket.connection = null;\r\n\r\n                        for(var uid in _qz.websocket.pendingCalls) {\r\n                            if (_qz.websocket.pendingCalls.hasOwnProperty(uid)) {\r\n                                _qz.websocket.pendingCalls[uid].reject(new Error(\"Connection closed before response received\"));\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    //called for any errors with an open connection\r\n                    _qz.websocket.connection.onerror = function(evt) {\r\n                        _qz.websocket.callError(evt);\r\n                    };\r\n\r\n                    //send JSON objects to qz\r\n                    _qz.websocket.connection.sendData = function(obj) {\r\n                        _qz.log.trace(\"Preparing object for websocket\", obj);\r\n\r\n                        if (obj.timestamp == undefined) {\r\n                            obj.timestamp = Date.now();\r\n                            if (typeof obj.timestamp !== 'number') {\r\n                                obj.timestamp = new Date().getTime();\r\n                            }\r\n                        }\r\n                        if (obj.promise != undefined) {\r\n                            obj.uid = _qz.websocket.setup.newUID();\r\n                            _qz.websocket.pendingCalls[obj.uid] = obj.promise;\r\n                        }\r\n\r\n                        // track requesting monitor\r\n                        obj.position = {\r\n                            x: screen ? ((screen.availWidth || screen.width) / 2) + (screen.left || screen.availLeft) : 0,\r\n                            y: screen ? ((screen.availHeight || screen.height) / 2) + (screen.top || screen.availTop) : 0\r\n                        };\r\n\r\n                        try {\r\n                            if (obj.call != undefined && obj.signature == undefined) {\r\n                                var signObj = {\r\n                                    call: obj.call,\r\n                                    params: obj.params,\r\n                                    timestamp: obj.timestamp\r\n                                };\r\n\r\n                                //make a hashing promise if not already one\r\n                                var hashing = _qz.tools.hash(_qz.tools.stringify(signObj));\r\n                                if (!hashing.then) {\r\n                                    hashing = _qz.tools.promise(function(resolve) {\r\n                                        resolve(hashing);\r\n                                    });\r\n                                }\r\n\r\n                                hashing.then(function(hashed) {\r\n                                    return _qz.security.callSign(hashed);\r\n                                }).then(function(signature) {\r\n                                    _qz.log.trace(\"Signature for call\", signature);\r\n                                    obj.signature = signature;\r\n                                    _qz.signContent = undefined;\r\n                                    _qz.websocket.connection.send(_qz.tools.stringify(obj));\r\n                                });\r\n                            } else {\r\n                                _qz.log.trace(\"Signature for call\", obj.signature);\r\n\r\n                                //called for pre-signed content and (unsigned) setup calls\r\n                                _qz.websocket.connection.send(_qz.tools.stringify(obj));\r\n                            }\r\n                        }\r\n                        catch(err) {\r\n                            _qz.log.error(err);\r\n\r\n                            if (obj.promise != undefined) {\r\n                                obj.promise.reject(err);\r\n                                delete _qz.websocket.pendingCalls[obj.uid];\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    //receive message from qz\r\n                    _qz.websocket.connection.onmessage = function(evt) {\r\n                        var returned = JSON.parse(evt.data);\r\n\r\n                        if (returned.uid == null) {\r\n                            if (returned.type == null) {\r\n                                //incorrect response format, likely connected to incompatible qz version\r\n                                _qz.websocket.connection.close(4003, \"Connected to incompatible QZ Tray version\");\r\n\r\n                            } else {\r\n                                //streams (callbacks only, no promises)\r\n                                switch(returned.type) {\r\n                                    case _qz.streams.serial:\r\n                                        if (!returned.event) {\r\n                                            returned.event = JSON.stringify({ portName: returned.key, output: returned.data });\r\n                                        }\r\n\r\n                                        _qz.serial.callSerial(JSON.parse(returned.event));\r\n                                        break;\r\n                                    case _qz.streams.usb:\r\n                                        if (!returned.event) {\r\n                                            returned.event = JSON.stringify({ vendorId: returned.key[0], productId: returned.key[1], output: returned.data });\r\n                                        }\r\n\r\n                                        _qz.usb.callUsb(JSON.parse(returned.event));\r\n                                        break;\r\n                                    case _qz.streams.hid:\r\n                                        _qz.hid.callHid(JSON.parse(returned.event));\r\n                                        break;\r\n                                    default:\r\n                                        _qz.log.warn(\"Cannot determine stream type for callback\", returned);\r\n                                        break;\r\n                                }\r\n                            }\r\n\r\n                            return;\r\n                        }\r\n\r\n                        _qz.log.trace(\"Received response from websocket\", returned);\r\n\r\n                        var promise = _qz.websocket.pendingCalls[returned.uid];\r\n                        if (promise == undefined) {\r\n                            _qz.log.warn('No promise found for returned response');\r\n                        } else {\r\n                            if (returned.error != undefined) {\r\n                                promise.reject(new Error(returned.error));\r\n                            } else {\r\n                                promise.resolve(returned.result);\r\n                            }\r\n                        }\r\n\r\n                        delete _qz.websocket.pendingCalls[returned.uid];\r\n                    };\r\n\r\n\r\n                    //send up the certificate before making any calls\r\n                    //also gives the user a chance to deny the connection\r\n                    function sendCert(cert) {\r\n                        if (cert === undefined) { cert = null; }\r\n                        _qz.websocket.connection.sendData({ certificate: cert, promise: openPromise });\r\n                    }\r\n\r\n                    _qz.security.callCert().then(sendCert).catch(sendCert);\r\n                },\r\n\r\n                /** Generate unique ID used to map a response to a call. */\r\n                newUID: function() {\r\n                    var len = 6;\r\n                    return (new Array(len + 1).join(\"0\") + (Math.random() * Math.pow(36, len) << 0).toString(36)).slice(-len)\r\n                }\r\n            },\r\n\r\n            dataPromise: function(callName, params, signature, signingTimestamp) {\r\n                return _qz.tools.promise(function(resolve, reject) {\r\n                    var msg = {\r\n                        call: callName,\r\n                        promise: { resolve: resolve, reject: reject },\r\n                        params: params,\r\n                        signature: signature,\r\n                        timestamp: signingTimestamp\r\n                    };\r\n\r\n                    _qz.websocket.connection.sendData(msg);\r\n                });\r\n            },\r\n\r\n            /** Library of promises awaiting a response, uid -> promise */\r\n            pendingCalls: {},\r\n\r\n            /** List of functions to call on error from the websocket. */\r\n            errorCallbacks: [],\r\n            /** Calls all functions registered to listen for errors. */\r\n            callError: function(evt) {\r\n                if (Array.isArray(_qz.websocket.errorCallbacks)) {\r\n                    for(var i = 0; i < _qz.websocket.errorCallbacks.length; i++) {\r\n                        _qz.websocket.errorCallbacks[i](evt);\r\n                    }\r\n                } else {\r\n                    _qz.websocket.errorCallbacks(evt);\r\n                }\r\n            },\r\n\r\n            /** List of function to call on closing from the websocket. */\r\n            closedCallbacks: [],\r\n            /** Calls all functions registered to listen for closing. */\r\n            callClose: function(evt) {\r\n                if (Array.isArray(_qz.websocket.closedCallbacks)) {\r\n                    for(var i = 0; i < _qz.websocket.closedCallbacks.length; i++) {\r\n                        _qz.websocket.closedCallbacks[i](evt);\r\n                    }\r\n                } else {\r\n                    _qz.websocket.closedCallbacks(evt);\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        printing: {\r\n            /** Default options used for new printer configs. Can be overridden using {@link qz.configs.setDefaults}. */\r\n            defaultConfig: {\r\n                //value purposes are explained in the qz.configs.setDefaults docs\r\n\r\n                colorType: 'color',\r\n                copies: 1,\r\n                density: 0,\r\n                duplex: false,\r\n                fallbackDensity: null,\r\n                interpolation: 'bicubic',\r\n                jobName: null,\r\n                legacy: false,\r\n                margins: 0,\r\n                orientation: null,\r\n                paperThickness: null,\r\n                printerTray: null,\r\n                rasterize: true,\r\n                rotation: 0,\r\n                scaleContent: true,\r\n                size: null,\r\n                units: 'in',\r\n\r\n                altPrinting: false,\r\n                encoding: null,\r\n                endOfDoc: null,\r\n                perSpool: 1\r\n            }\r\n        },\r\n\r\n\r\n        serial: {\r\n            /** List of functions called when receiving data from serial connection. */\r\n            serialCallbacks: [],\r\n            /** Calls all functions registered to listen for serial events. */\r\n            callSerial: function(streamEvent) {\r\n                if (Array.isArray(_qz.serial.serialCallbacks)) {\r\n                    for(var i = 0; i < _qz.serial.serialCallbacks.length; i++) {\r\n                        _qz.serial.serialCallbacks[i](streamEvent);\r\n                    }\r\n                } else {\r\n                    _qz.serial.serialCallbacks(streamEvent);\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        usb: {\r\n            /** List of functions called when receiving data from usb connection. */\r\n            usbCallbacks: [],\r\n            /** Calls all functions registered to listen for usb events. */\r\n            callUsb: function(streamEvent) {\r\n                if (Array.isArray(_qz.usb.usbCallbacks)) {\r\n                    for(var i = 0; i < _qz.usb.usbCallbacks.length; i++) {\r\n                        _qz.usb.usbCallbacks[i](streamEvent);\r\n                    }\r\n                } else {\r\n                    _qz.usb.usbCallbacks(streamEvent);\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        hid: {\r\n            /** List of functions called when receiving data from hid connection. */\r\n            hidCallbacks: [],\r\n            /** Calls all functions registered to listen for hid events. */\r\n            callHid: function(streamEvent) {\r\n                if (Array.isArray(_qz.hid.hidCallbacks)) {\r\n                    for(var i = 0; i < _qz.hid.hidCallbacks.length; i++) {\r\n                        _qz.hid.hidCallbacks[i](streamEvent);\r\n                    }\r\n                } else {\r\n                    _qz.hid.hidCallbacks(streamEvent);\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        security: {\r\n            /** Function used to resolve promise when acquiring site's public certificate. */\r\n            certPromise: function(resolve, reject) { reject(); },\r\n            /** Called to create new promise (using {@link _qz.security.certPromise}) for certificate retrieval. */\r\n            callCert: function() {\r\n                return _qz.tools.promise(_qz.security.certPromise);\r\n            },\r\n\r\n            /** Function used to create promise resolver when requiring signed calls. */\r\n            signaturePromise: function() { return function(resolve) { resolve(); } },\r\n            /** Called to create new promise (using {@link _qz.security.signaturePromise}) for signed calls. */\r\n            callSign: function(toSign) {\r\n                return _qz.tools.promise(_qz.security.signaturePromise(toSign));\r\n            }\r\n        },\r\n\r\n\r\n        tools: {\r\n            /** Create a new promise */\r\n            promise: function(resolver) {\r\n                return new RSVP.Promise(resolver);\r\n            },\r\n\r\n            stringify: function(object) {\r\n                //old versions of prototype affect stringify\r\n                var pjson = Array.prototype.toJSON;\r\n                delete Array.prototype.toJSON;\r\n\r\n                var result = JSON.stringify(object);\r\n\r\n                if (pjson) {\r\n                    Array.prototype.toJSON = pjson;\r\n                }\r\n\r\n                return result;\r\n            },\r\n\r\n            hash: function(data) {\r\n                return Sha256.hash(data);\r\n            },\r\n\r\n            ws: typeof WebSocket !== 'undefined' ? WebSocket : null,\r\n\r\n            absolute: function(loc) {\r\n                if (typeof window !== 'undefined' && typeof document.createElement === 'function') {\r\n                    var a = document.createElement(\"a\");\r\n                    a.href = loc;\r\n                    return a.href;\r\n                }\r\n                return loc;\r\n            },\r\n\r\n            /** Performs deep copy to target from remaining params */\r\n            extend: function(target) {\r\n                //special case when reassigning properties as objects in a deep copy\r\n                if (typeof target !== 'object') {\r\n                    target = {};\r\n                }\r\n\r\n                for(var i = 1; i < arguments.length; i++) {\r\n                    var source = arguments[i];\r\n                    if (!source) { continue; }\r\n\r\n                    for(var key in source) {\r\n                        if (source.hasOwnProperty(key)) {\r\n                            if (target === source[key]) { continue; }\r\n\r\n                            if (source[key] && source[key].constructor && source[key].constructor === Object) {\r\n                                var clone;\r\n                                if (Array.isArray(source[key])) {\r\n                                    clone = target[key] || [];\r\n                                } else {\r\n                                    clone = target[key] || {};\r\n                                }\r\n\r\n                                target[key] = _qz.tools.extend(clone, source[key]);\r\n                            } else if (source[key] !== undefined) {\r\n                                target[key] = source[key];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return target;\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n///// CONFIG CLASS ////\r\n\r\n    /** Object to handle configured printer options. */\r\n    function Config(printer, opts) {\r\n        /**\r\n         * Set the printer assigned to this config.\r\n         * @param {string|Object} newPrinter Name of printer. Use object type to specify printing to file or host.\r\n         *  @param {string} [newPrinter.name] Name of printer to send printing.\r\n         *  @param {string} [newPrinter.file] Name of file to send printing.\r\n         *  @param {string} [newPrinter.host] IP address or host name to send printing.\r\n         *  @param {string} [newPrinter.port] Port used by &lt;printer.host>.\r\n         */\r\n        this.setPrinter = function(newPrinter) {\r\n            if (typeof newPrinter === 'string') {\r\n                newPrinter = { name: newPrinter };\r\n            }\r\n\r\n            this.printer = newPrinter;\r\n        };\r\n\r\n        /**\r\n         *  @returns {Object} The printer currently assigned to this config.\r\n         */\r\n        this.getPrinter = function() {\r\n            return this.printer;\r\n        };\r\n\r\n        /**\r\n         * Alter any of the printer options currently applied to this config.\r\n         * @param newOpts {Object} The options to change. See <code>qz.config.setDefaults</code> docs for available values.\r\n         *\r\n         * @see qz.config.setDefaults\r\n         */\r\n        this.reconfigure = function(newOpts) {\r\n            _qz.tools.extend(this.config, newOpts);\r\n        };\r\n\r\n        /**\r\n         * @returns {Object} The currently applied options on this config.\r\n         */\r\n        this.getOptions = function() {\r\n            return this.config;\r\n        };\r\n\r\n        // init calls for new config object\r\n        this.setPrinter(printer);\r\n        this.config = opts;\r\n    }\r\n\r\n    /**\r\n     * Shortcut method for calling <code>qz.print</code> with a particular config.\r\n     * @param {Array<Object|string>} data Array of data being sent to the printer. See <code>qz.print</code> docs for available values.\r\n     * @param {boolean} [signature] Pre-signed signature of JSON string containing <code>call</code>, <code>params</code>, and <code>timestamp</code>.\r\n     * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\r\n     *\r\n     * @example\r\n     * qz.print(myConfig, ...); // OR\r\n     * myConfig.print(...);\r\n     *\r\n     * @see qz.print\r\n     */\r\n    Config.prototype.print = function(data, signature, signingTimestamp) {\r\n        qz.print(this, data, signature, signingTimestamp);\r\n    };\r\n\r\n\r\n///// PUBLIC METHODS /////\r\n\r\n    /** @namespace qz */\r\n    return {\r\n\r\n        /**\r\n         * Calls related specifically to the web socket connection.\r\n         * @namespace qz.websocket\r\n         */\r\n        websocket: {\r\n            /**\r\n             * Check connection status. Active connection is necessary for other calls to run.\r\n             *\r\n             * @returns {boolean} If there is an active connection with QZ Tray.\r\n             *\r\n             * @see connect\r\n             *\r\n             * @memberof  qz.websocket\r\n             */\r\n            isActive: function() {\r\n                return _qz.websocket.connection != null && _qz.websocket.connection.established;\r\n            },\r\n\r\n            /**\r\n             * Call to setup connection with QZ Tray on user's system.\r\n             *\r\n             * @param {Object} [options] Configuration options for the web socket connection.\r\n             *  @param {string|Array<string>} [options.host=['localhost', 'localhost.qz.io']] Host running the QZ Tray software.\r\n             *  @param {Object} [options.port] Config options for ports to cycle.\r\n             *   @param {Array<number>} [options.port.secure=[8181, 8282, 8383, 8484]] Array of secure (WSS) ports to try\r\n             *   @param {Array<number>} [options.port.insecure=[8182, 8283, 8384, 8485]] Array of insecure (WS) ports to try\r\n             *  @param {boolean} [options.usingSecure=true] If the web socket should try to use secure ports for connecting.\r\n             *  @param {number} [options.keepAlive=60] Seconds between keep-alive pings to keep connection open. Set to 0 to disable.\r\n             *  @param {number} [options.retries=0] Number of times to reconnect before failing.\r\n             *  @param {number} [options.delay=0] Seconds before firing a connection.  Ignored if <code>options.retries</code> is 0.\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            connect: function(options) {\r\n                return _qz.tools.promise(function(resolve, reject) {\r\n                    if (qz.websocket.isActive()) {\r\n                        reject(new Error(\"An open connection with QZ Tray already exists\"));\r\n                        return;\r\n                    } else if (_qz.websocket.connection != null) {\r\n                        reject(new Error(\"The current connection attempt has not returned yet\"));\r\n                        return;\r\n                    }\r\n\r\n                    if (!_qz.tools.ws) {\r\n                        reject(new Error(\"WebSocket not supported by this browser\"));\r\n                        return;\r\n                    } else if (!_qz.tools.ws.CLOSED || _qz.tools.ws.CLOSED == 2) {\r\n                        reject(new Error(\"Unsupported WebSocket version detected: HyBi-00/Hixie-76\"));\r\n                        return;\r\n                    }\r\n\r\n                    //ensure some form of options exists for value checks\r\n                    if (options == undefined) { options = {}; }\r\n\r\n                    //disable secure ports if page is not secure\r\n                    if (typeof location === 'undefined' || location.protocol !== 'https:') {\r\n                        //respect forcing secure ports if it is defined, otherwise disable\r\n                        if (typeof options.usingSecure === 'undefined') {\r\n                            _qz.log.trace(\"Disabling secure ports due to insecure page\");\r\n                            options.usingSecure = false;\r\n                        }\r\n                    }\r\n\r\n                    //ensure any hosts are passed to internals as an array\r\n                    if (typeof options.host !== 'undefined' && !Array.isArray(options.host)) {\r\n                        options.host = [options.host];\r\n                    }\r\n\r\n                    var attempt = function(count) {\r\n                        var tried = false;\r\n                        var nextAttempt = function() {\r\n                            if (!tried) {\r\n                                tried = true;\r\n\r\n                                if (options && count < options.retries) {\r\n                                    attempt(count + 1);\r\n                                } else {\r\n                                    reject.apply(null, arguments);\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        var delayed = function() {\r\n                            var config = _qz.tools.extend({}, _qz.websocket.connectConfig, options);\r\n                            _qz.websocket.setup.findConnection(config, resolve, nextAttempt)\r\n                        };\r\n                        if (count == 0) {\r\n                            delayed(); // only retries will be called with a delay\r\n                        } else {\r\n                            setTimeout(delayed, options.delay * 1000);\r\n                        }\r\n                    };\r\n\r\n                    attempt(0);\r\n                });\r\n            },\r\n\r\n            /**\r\n             * Stop any active connection with QZ Tray.\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            disconnect: function() {\r\n                return _qz.tools.promise(function(resolve, reject) {\r\n                    if (qz.websocket.isActive()) {\r\n                        _qz.websocket.connection.close();\r\n                        _qz.websocket.connection.promise = { resolve: resolve, reject: reject };\r\n                    } else {\r\n                        reject(new Error(\"No open connection with QZ Tray\"))\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * List of functions called for any connections errors outside of an API call.<p/>\r\n             * Also called if {@link websocket#connect} fails to connect.\r\n             *\r\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Event} event)</code> calls.\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            setErrorCallbacks: function(calls) {\r\n                _qz.websocket.errorCallbacks = calls;\r\n            },\r\n\r\n            /**\r\n             * List of functions called for any connection closing event outside of an API call.<p/>\r\n             * Also called when {@link websocket#disconnect} is called.\r\n             *\r\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Event} event)</code> calls.\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            setClosedCallbacks: function(calls) {\r\n                _qz.websocket.closedCallbacks = calls;\r\n            },\r\n\r\n            /**\r\n             * @param {string} [hostname] Hostname to try to connect to when determining network interfaces, defaults to \"google.com\"\r\n             * @param {number} [port] Port to use with custom hostname, defaults to 443\r\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='websocket.getNetworkInfo'</code>, <code>params</code> object, and <code>timestamp</code>.\r\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\r\n             *\r\n             * @returns {Promise<Object<{ipAddress: String, macAddress: String}>|Error>} Connected system's network information.\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            getNetworkInfo: function(hostname, port, signature, signingTimestamp) {\r\n                return _qz.websocket.dataPromise('websocket.getNetworkInfo', {\r\n                    hostname: hostname,\r\n                    port: port\r\n                }, signature, signingTimestamp);\r\n            },\r\n\r\n            /**\r\n             * @returns {Object<{socket: String, host: String, port: Number}>} Details of active websocket connection\r\n             *\r\n             * @memberof qz.websocket\r\n             */\r\n            getConnectionInfo: function() {\r\n                if (_qz.websocket.connection) {\r\n                    var url = _qz.websocket.connection.url.split(/[:\\/]+/g);\r\n                    return { socket: url[0], host: url[1], port: +url[2] };\r\n                } else {\r\n                    throw new Error(\"A connection to QZ has not been established yet\");\r\n                }\r\n            }\r\n\r\n        },\r\n\r\n\r\n        /**\r\n         * Calls related to getting printer information from the connection.\r\n         * @namespace qz.printers\r\n         */\r\n        printers: {\r\n            /**\r\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='printers.getDefault</code>, <code>params</code>, and <code>timestamp</code>.\r\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\r\n             *\r\n             * @returns {Promise<string|Error>} Name of the connected system's default printer.\r\n             *\r\n             * @memberof qz.printers\r\n             */\r\n            getDefault: function(signature, signingTimestamp) {\r\n                return _qz.websocket.dataPromise('printers.getDefault', null, signature, signingTimestamp);\r\n            },\r\n\r\n            /**\r\n             * @param {string} [query] Search for a specific printer. All printers are returned if not provided.\r\n             * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='printers.find'</code>, <code>params</code>, and <code>timestamp</code>.\r\n             * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\r\n             *\r\n             * @returns {Promise<Array<string>|string|Error>} The matched printer name if <code>query</code> is provided.\r\n             *                                                Otherwise an array of printer names found on the connected system.\r\n             *\r\n             * @memberof qz.printers\r\n             */\r\n            find: function(query, signature, signingTimestamp) {\r\n                return _qz.websocket.dataPromise('printers.find', { query: query }, signature, signingTimestamp);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Calls related to setting up new printer configurations.\r\n         * @namespace qz.configs\r\n         */\r\n        configs: {\r\n            /**\r\n             * Default options used by new configs if not overridden.\r\n             * Setting a value to NULL will use the printer's default options.\r\n             * Updating these will not update the options on any created config.\r\n             *\r\n             * @param {Object} options Default options used by printer configs if not overridden.\r\n             *\r\n             *  @param {string} [options.colorType='color'] Valid values <code>[color | grayscale | blackwhite]</code>\r\n             *  @param {number} [options.copies=1] Number of copies to be printed.\r\n             *  @param {number|Array<number>} [options.density=72] Pixel density (DPI, DPMM, or DPCM depending on <code>[options.units]</code>).\r\n             *      If provided as an array, uses the first supported density found (or the first entry if none found).\r\n             *  @param {boolean} [options.duplex=false] Double sided printing\r\n             *  @param {number} [options.fallbackDensity=null] Value used when default density value cannot be read, or in cases where reported as \"Normal\" by the driver, (in DPI, DPMM, or DPCM depending on <code>[options.units]</code>).\r\n             *  @param {string} [options.interpolation='bicubic'] Valid values <code>[bicubic | bilinear | nearest-neighbor]</code>. Controls how images are handled when resized.\r\n             *  @param {string} [options.jobName=null] Name to display in print queue.\r\n             *  @param {boolean} [options.legacy=false] If legacy style printing should be used.\r\n             *  @param {Object|number} [options.margins=0] If just a number is provided, it is used as the margin for all sides.\r\n             *   @param {number} [options.margins.top=0]\r\n             *   @param {number} [options.margins.right=0]\r\n             *   @param {number} [options.margins.bottom=0]\r\n             *   @param {number} [options.margins.left=0]\r\n             *  @param {string} [options.orientation=null] Valid values <code>[portrait | landscape | reverse-landscape]</code>\r\n             *  @param {number} [options.paperThickness=null]\r\n             *  @param {string} [options.printerTray=null] //TODO - string?\r\n             *  @param {boolean} [options.rasterize=true] Whether documents should be rasterized before printing. Forced TRUE if <code>[options.density]</code> is specified.\r\n             *  @param {number} [options.rotation=0] Image rotation in degrees.\r\n             *  @param {boolean} [options.scaleContent=true] Scales print content to page size, keeping ratio.\r\n             *  @param {Object} [options.size=null] Paper size.\r\n             *   @param {number} [options.size.width=null] Page width.\r\n             *   @param {number} [options.size.height=null] Page height.\r\n             *  @param {string} [options.units='in'] Page units, applies to paper size, margins, and density. Valid value <code>[in | cm | mm]</code>\r\n             *\r\n             *  @param {boolean} [options.altPrinting=false] Print the specified file using CUPS command line arguments.  Has no effect on Windows.\r\n             *  @param {string} [options.encoding=null] Character set\r\n             *  @param {string} [options.endOfDoc=null]\r\n             *  @param {number} [options.perSpool=1] Number of pages per spool.\r\n             *\r\n             * @memberof qz.configs\r\n             */\r\n            setDefaults: function(options) {\r\n                _qz.tools.extend(_qz.printing.defaultConfig, options);\r\n            },\r\n\r\n            /**\r\n             * Creates new printer config to be used in printing.\r\n             *\r\n             * @param {string|object} printer Name of printer. Use object type to specify printing to file or host.\r\n             *  @param {string} [printer.name] Name of printer to send printing.\r\n             *  @param {string} [printer.file] Name of file to send printing.\r\n             *  @param {string} [printer.host] IP address or host name to send printing.\r\n             *  @param {string} [printer.port] Port used by &lt;printer.host>.\r\n             * @param {Object} [options] Override any of the default options for this config only.\r\n             *\r\n             * @returns {Config} The new config.\r\n             *\r\n             * @see config.setDefaults\r\n             *\r\n             * @memberof qz.configs\r\n             */\r\n            create: function(printer, options) {\r\n                var myOpts = _qz.tools.extend({}, _qz.printing.defaultConfig, options);\r\n                return new Config(printer, myOpts);\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * Send data to selected config for printing.\r\n         * The promise for this method will resolve when the document has been sent to the printer. Actual printing may not be complete.\r\n         * <p/>\r\n         * Optionally, print requests can be pre-signed:\r\n         * Signed content consists of a JSON object string containing no spacing,\r\n         * following the format of the \"call\" and \"params\" keys in the API call, with the addition of a \"timestamp\" key in milliseconds\r\n         * ex. <code>'{\"call\":\"<callName>\",\"params\":{...},\"timestamp\":1450000000}'</code>\r\n         *\r\n         * @param {Object<Config>} config Previously created config object.\r\n         * @param {Array<Object|string>} data Array of data being sent to the printer. String values are interpreted the same as the default <code>[raw]</code> object value.\r\n         *  @param {string} data.data\r\n         *  @param {string} data.type Valid values <code>[html | image | pdf | raw]</code>\r\n         *  @param {string} [data.format] Format of data provided.<p/>\r\n         *      For <code>[html]</code> types, valid formats include <code>[file(default) | plain]</code>.<p/>\r\n         *      For <code>[image]</code> types, valid formats include <code>[base64 | file(default)]</code>.<p/>\r\n         *      For <code>[pdf]</code> types, valid format include <code>[base64 | file(default)]</code>.<p/>\r\n         *      For <code>[raw]</code> types, valid formats include <code>[base64 | file | hex | plain(default) | image | xml]</code>.\r\n         *  @param {Object} [data.options]\r\n         *   @param {string} [data.options.language] Required with <code>[raw]</code> type <code>[image]</code> format. Printer language.\r\n         *   @param {number} [data.options.x] Optional with <code>[raw]</code> type <code>[image]</code> format. The X position of the image.\r\n         *   @param {number} [data.options.y] Optional with <code>[raw]</code> type <code>[image]</code> format. The Y position of the image.\r\n         *   @param {string|number} [data.options.dotDensity] Optional with <code>[raw]</code> type <code>[image]</code> format.\r\n         *   @param {number} [data.precision=128] Optional with <code>[raw]</code> type <code>[image]</code> format. Bit precision of the ribbons.\r\n         *   @param {boolean|string|Array<Array<number>>} [data.options.overlay=false] Optional with <code>[raw]</code> type <code>[image]</code> format.\r\n         *      Boolean sets entire layer, string sets mask image, Array sets array of rectangles in format <code>[x1,y1,x2,y2]</code>.\r\n         *   @param {string} [data.options.xmlTag] Required with <code>[xml]</code> format. Tag name containing base64 formatted data.\r\n         *   @param {number} [data.options.pageWidth] Optional with <code>[html]</code> type printing. Width of the web page to render. Defaults to paper width.\r\n         *   @param {number} [data.options.pageHeight] Optional with <code>[html]</code> type printing. Height of the web page to render. Defaults to adjusted web page height.\r\n         * @param {string} [signature] Pre-signed signature of hashed JSON string containing <code>call='print'</code>, <code>params</code>, and <code>timestamp</code>.\r\n         * @param {number} [signingTimestamp] Required with <code>signature</code>. Timestamp used with pre-signed content.\r\n         *\r\n         * @returns {Promise<null|Error>}\r\n         *\r\n         * @see qz.config.create\r\n         *\r\n         * @memberof qz\r\n         */\r\n        print: function(config, data, signature, signingTimestamp) {\r\n            //change relative links to absolute\r\n            for(var i = 0; i < data.length; i++) {\r\n                if (data[i].constructor === Object) {\r\n                    if ((!data[i].format && data[i].type && (data[i].type.toUpperCase() !== 'RAW' && data[i].type.toUpperCase() !== 'DIRECT')) //unspecified format and not raw -> assume file\r\n                        || (data[i].format && (data[i].format.toUpperCase() === 'FILE'\r\n                            || (data[i].format.toUpperCase() === 'IMAGE' && !(data[i].data.indexOf(\"data:image/\") === 0 && data[i].data.indexOf(\";base64,\") !== 0))\r\n                            || data[i].format.toUpperCase() === 'XML'))) {\r\n                        data[i].data = _qz.tools.absolute(data[i].data);\r\n                    }\r\n                    if (data[i].options && typeof data[i].options.overlay === 'string') {\r\n                        data[i].options.overlay = _qz.tools.absolute(data[i].options.overlay);\r\n                    }\r\n                }\r\n            }\r\n\r\n            var params = {\r\n                printer: config.getPrinter(),\r\n                options: config.getOptions(),\r\n                data: data\r\n            };\r\n            return _qz.websocket.dataPromise('print', params, signature, signingTimestamp);\r\n        },\r\n\r\n\r\n        /**\r\n         * Calls related to interaction with serial ports.\r\n         * @namespace qz.serial\r\n         */\r\n        serial: {\r\n            /**\r\n             * @returns {Promise<Array<string>|Error>} Communication (RS232, COM, TTY) ports available on connected system.\r\n             *\r\n             * @memberof qz.serial\r\n             */\r\n            findPorts: function() {\r\n                return _qz.websocket.dataPromise('serial.findPorts');\r\n            },\r\n\r\n            /**\r\n             * List of functions called for any response from open serial ports.\r\n             * Event data will contain <code>{string} portName</code> for all types.\r\n             *  For RECEIVE types, <code>{string} output</code>.\r\n             *  For ERROR types, <code>{string} exception</code>.\r\n             *\r\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({string} portName, {string} output)</code> calls.\r\n             *\r\n             * @memberof qz.serial\r\n             */\r\n            setSerialCallbacks: function(calls) {\r\n                _qz.serial.serialCallbacks = calls;\r\n            },\r\n\r\n            /**\r\n             * @param {string} port Name of port to open.\r\n             * @param {Object} [options] Boundaries of serial port output.\r\n             *  @param {string} [options.start=0x0002] Character denoting start of serial response. Not used if <code>width</code is provided.\r\n             *  @param {string} [options.end=0x000D] Character denoting end of serial response. Not used if <code>width</code> is provided.\r\n             *  @param {number} [options.width] Used for fixed-width response serial communication.\r\n             *  @param {string} [options.baudRate=9600]\r\n             *  @param {string} [options.dataBits=8]\r\n             *  @param {string} [options.stopBits=1]\r\n             *  @param {string} [options.parity='NONE'] Valid values <code>[NONE| EVEN | ODD | MARK | SPACE]</code>\r\n             *  @param {string} [options.flowControl='NONE'] Valid values <code>[NONE | XONXOFF | XONXOFF_OUT | XONXOFF_IN | RTSCTS | RTSCTS_OUT | RTSCTS_IN]</code>\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.serial\r\n             */\r\n            openPort: function(port, options) {\r\n                var params = {\r\n                    port: port,\r\n                    options: options\r\n                };\r\n                return _qz.websocket.dataPromise('serial.openPort', params);\r\n            },\r\n\r\n            /**\r\n             * Send commands over a serial port.\r\n             * Any responses from the device will be sent to serial callback functions.\r\n             *\r\n             * @param {string} port An open port to send data over.\r\n             * @param {string} data The data to send to the serial device.\r\n             * @param {Object} [properties] DEPRECATED: Properties of data being sent over the serial port.\r\n             *  @param {string} [properties.baudRate=9600]\r\n             *  @param {string} [properties.dataBits=8]\r\n             *  @param {string} [properties.stopBits=1]\r\n             *  @param {string} [properties.parity='NONE'] Valid values <code>[NONE| EVEN | ODD | MARK | SPACE]</code>\r\n             *  @param {string} [properties.flowControl='NONE'] Valid values <code>[NONE | XONXOFF | XONXOFF_OUT | XONXOFF_IN | RTSCTS | RTSCTS_OUT | RTSCTS_IN]</code>\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @see qz.serial.setSerialCallbacks\r\n             *\r\n             * @memberof qz.serial\r\n             */\r\n            sendData: function(port, data, properties) {\r\n                if (properties != null) {\r\n                    _qz.log.warn(\"Properties object is deprecated on sendData calls, use openPort instead.\");\r\n                }\r\n\r\n                var params = {\r\n                    port: port,\r\n                    data: data,\r\n                    properties: properties\r\n                };\r\n                return _qz.websocket.dataPromise('serial.sendData', params);\r\n            },\r\n\r\n            /**\r\n             * @param {string} port Name of port to close.\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.serial\r\n             */\r\n            closePort: function(port) {\r\n                return _qz.websocket.dataPromise('serial.closePort', { port: port });\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * Calls related to interaction with USB devices.\r\n         * @namespace qz.usb\r\n         */\r\n        usb: {\r\n            /**\r\n             * List of available USB devices. Includes (hexadecimal) vendor ID, (hexadecimal) product ID, and hub status.\r\n             * If supported, also returns manufacturer and product descriptions.\r\n             *\r\n             * @param includeHubs Whether to include USB hubs.\r\n             * @returns {Promise<Array<Object>|Error>} Array of JSON objects containing information on connected USB devices.\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            listDevices: function(includeHubs) {\r\n                return _qz.websocket.dataPromise('usb.listDevices', { includeHubs: includeHubs });\r\n            },\r\n\r\n            /**\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             * @returns {Promise<Array<string>|Error>} List of available (hexadecimal) interfaces on a USB device.\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            listInterfaces: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('usb.listInterfaces', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.iface Hex string of interface on the USB device to search.\r\n             * @returns {Promise<Array<string>|Error>} List of available (hexadecimal) endpoints on a USB device's interface.\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            listEndpoints: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        interface: arguments[2]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.listEndpoints', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * List of functions called for any response from open usb devices.\r\n             * Event data will contain <code>{string} vendorId</code> and <code>{string} productId</code> for all types.\r\n             *  For RECEIVE types, <code>{Array} output</code> (in hexadecimal format).\r\n             *  For ERROR types, <code>{string} exception</code>.\r\n             *\r\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            setUsbCallbacks: function(calls) {\r\n                _qz.usb.usbCallbacks = calls;\r\n            },\r\n\r\n            /**\r\n             * Claim a USB device's interface to enable sending/reading data across an endpoint.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.interface Hex string of interface on the USB device to claim.\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            claimDevice: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        interface: arguments[2]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.claimDevice', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Check the current claim state of a USB device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             * @returns {Promise<boolean|Error>}\r\n             *\r\n             * @since 2.0.2\r\n             * @memberOf qz.usb\r\n             */\r\n            isClaimed: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('usb.isClaimed', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Send data to a claimed USB device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\r\n             *  @param deviceInfo.data Bytes to send over specified endpoint.\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            sendData: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        endpoint: arguments[2],\r\n                        data: arguments[3]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.sendData', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Read data from a claimed USB device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\r\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\r\n             * @returns {Promise<Array<string>|Error>} List of (hexadecimal) bytes received from the USB device.\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            readData: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        endpoint: arguments[2],\r\n                        responseSize: arguments[3]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.readData', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Provides a continuous stream of read data from a claimed USB device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\r\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\r\n             *  @param deviceInfo.interval=100 Frequency to send read data back, in milliseconds.\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @see qz.usb.setUsbCallbacks\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            openStream: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        endpoint: arguments[2],\r\n                        responseSize: arguments[3],\r\n                        interval: arguments[4]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.openStream', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Stops the stream of read data from a claimed USB device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             *  @param deviceInfo.endpoint Hex string of endpoint on the claimed interface for the USB device.\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            closeStream: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        endpoint: arguments[2]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('usb.closeStream', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Release a claimed USB device to free resources after sending/reading data.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of USB device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of USB device's product ID.\r\n             * @returns {Promise<null|Error>}\r\n             *\r\n             * @memberof qz.usb\r\n             */\r\n            releaseDevice: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('usb.releaseDevice', deviceInfo);\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * Calls related to interaction with HID USB devices<br/>\r\n         * Many of these calls can be accomplished from the <code>qz.usb</code> namespace,\r\n         * but HID allows for simpler interaction\r\n         * @namespace qz.hid\r\n         * @since 2.0.1\r\n         */\r\n        hid: {\r\n            /**\r\n             * List of available HID devices. Includes (hexadecimal) vendor ID and (hexadecimal) product ID.\r\n             * If available, also returns manufacturer and product descriptions.\r\n             *\r\n             * @returns {Promise<Array<Object>|Error>} Array of JSON objects containing information on connected HID devices.\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            listDevices: function() {\r\n                return _qz.websocket.dataPromise('hid.listDevices');\r\n            },\r\n\r\n            /**\r\n             * Start listening for HID device actions, such as attach / detach events.\r\n             * Reported under the ACTION type in the streamEvent on callbacks.\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @see qz.hid.setHidCallbacks\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            startListening: function() {\r\n                return _qz.websocket.dataPromise('hid.startListening');\r\n            },\r\n\r\n            /**\r\n             * Stop listening for HID device actions.\r\n             *\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @see qz.hid.setHidCallbacks\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            stopListening: function() {\r\n                return _qz.websocket.dataPromise('hid.stopListening');\r\n            },\r\n\r\n            /**\r\n             * List of functions called for any response from open usb devices.\r\n             * Event data will contain <code>{string} vendorId</code> and <code>{string} productId</code> for all types.\r\n             *  For RECEIVE types, <code>{Array} output</code> (in hexadecimal format).\r\n             *  For ERROR types, <code>{string} exception</code>.\r\n             *  For ACTION types, <code>{string} actionType</code>.\r\n             *\r\n             * @param {Function|Array<Function>} calls Single or array of <code>Function({Object} eventData)</code> calls.\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            setHidCallbacks: function(calls) {\r\n                _qz.hid.hidCallbacks = calls;\r\n            },\r\n\r\n            /**\r\n             * Claim a HID device to enable sending/reading data across.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            claimDevice: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('hid.claimDevice', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Check the current claim state of a HID device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             * @returns {Promise<boolean|Error>}\r\n             *\r\n             * @since 2.0.2\r\n             * @memberOf qz.hid\r\n             */\r\n            isClaimed: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('hid.isClaimed', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Send data to a claimed HID device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             *  @param deviceInfo.data Bytes to send over specified endpoint.\r\n             *  @param deviceInfo.endpoint=0x00 First byte of the data packet signifying the HID report ID.\r\n             *                             Must be 0x00 for devices only supporting a single report.\r\n             *  @param deviceInfo.reportId=0x00 Alias for <code>deviceInfo.endpoint</code>. Not used if endpoint is provided.\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            sendData: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        data: arguments[2],\r\n                        endpoint: arguments[3]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('hid.sendData', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Read data from a claimed HID device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\r\n             * @returns {Promise<Array<string>|Error>} List of (hexadecimal) bytes received from the HID device.\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            readData: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        responseSize: arguments[2]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('hid.readData', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Provides a continuous stream of read data from a claimed HID device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             *  @param deviceInfo.responseSize Size of the byte array to receive a response in.\r\n             *  @param deviceInfo.interval=100 Frequency to send read data back, in milliseconds.\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @see qz.hid.setHidCallbacks\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            openStream: function(deviceInfo) {\r\n                //backwards compatibility\r\n                if (typeof deviceInfo !== 'object') {\r\n                    deviceInfo = {\r\n                        vendorId: arguments[0],\r\n                        productId: arguments[1],\r\n                        responseSize: arguments[2],\r\n                        interval: arguments[3]\r\n                    };\r\n                }\r\n\r\n                return _qz.websocket.dataPromise('hid.openStream', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Stops the stream of read data from a claimed HID device.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            closeStream: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('hid.closeStream', deviceInfo);\r\n            },\r\n\r\n            /**\r\n             * Release a claimed HID device to free resources after sending/reading data.\r\n             *\r\n             * @param {object} deviceInfo Config details of the HID device.\r\n             *  @param deviceInfo.vendorId Hex string of HID device's vendor ID.\r\n             *  @param deviceInfo.productId Hex string of HID device's product ID.\r\n             *  @param deviceInfo.usagePage Hex string of HID device's usage page when multiple are present.\r\n             *  @param deviceInfo.serial Serial ID of HID device.\r\n             * @returns {Promise<null|Error>}\r\n             * @since 2.0.1\r\n             *\r\n             * @memberof qz.hid\r\n             */\r\n            releaseDevice: function(deviceInfo) {\r\n                if (typeof deviceInfo !== 'object') { deviceInfo = { vendorId: arguments[0], productId: arguments[1] }; } //backwards compatibility\r\n\r\n                return _qz.websocket.dataPromise('hid.releaseDevice', deviceInfo);\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * Calls related to signing connection requests.\r\n         * @namespace qz.security\r\n         */\r\n        security: {\r\n            /**\r\n             * Set promise resolver for calls to acquire the site's certificate.\r\n             *\r\n             * @param {Function} promiseCall <code>Function({function} resolve)</code> called as promise for getting the public certificate.\r\n             *     Should call <code>resolve</code> parameter with the result.\r\n             *\r\n             * @memberof qz.security\r\n             */\r\n            setCertificatePromise: function(promiseCall) {\r\n                _qz.security.certPromise = promiseCall;\r\n            },\r\n\r\n            /**\r\n             * Set promise creator for calls to sign API calls.\r\n             *\r\n             * @param {Function} promiseGen <code>Function({function} toSign)</code> Should return a function, <code>Function({function} resolve)</code>, that\r\n             *     will sign the content and resolve the created promise.\r\n             * @memberof qz.security\r\n             */\r\n            setSignaturePromise: function(promiseGen) {\r\n                _qz.security.signaturePromise = promiseGen;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Calls related to compatibility adjustments\r\n         * @namespace qz.api\r\n         */\r\n        api: {\r\n            /**\r\n             * Show or hide QZ api debugging statements in the browser console.\r\n             *\r\n             * @param {boolean} show Whether the debugging logs for QZ should be shown. Hidden by default.\r\n             *\r\n             * @memberof qz.api\r\n             */\r\n            showDebug: function(show) {\r\n                _qz.DEBUG = show;\r\n            },\r\n\r\n            /**\r\n             * Get version of connected QZ Tray application.\r\n             *\r\n             * @returns {Promise<string|Error>} Version number of QZ Tray.\r\n             *\r\n             * @memberof qz.api\r\n             */\r\n            getVersion: function() {\r\n                return _qz.websocket.dataPromise('getVersion');\r\n            },\r\n\r\n            /**\r\n             * Change the promise library used by QZ API.\r\n             * Should be called before any initialization to avoid possible errors.\r\n             *\r\n             * @param {Function} promiser <code>Function({function} resolver)</code> called to create new promises.\r\n             *\r\n             * @memberof qz.api\r\n             */\r\n            setPromiseType: function(promiser) {\r\n                _qz.tools.promise = promiser;\r\n            },\r\n\r\n            /**\r\n             * Change the SHA-256 hashing function used by QZ API.\r\n             * Should be called before any initialization to avoid possible errors.\r\n             *\r\n             * @param {Function} hasher <code>Function({function} message)</code> called to create hash of passed string.\r\n             *\r\n             * @memberof qz.api\r\n             */\r\n            setSha256Type: function(hasher) {\r\n                _qz.tools.hash = hasher;\r\n            },\r\n\r\n            /**\r\n             * Change the WebSocket handler.\r\n             * Should be called before any initialization to avoid possible errors.\r\n             *\r\n             * @param {Function} ws <code>Function({function} WebSocket)</code> called to override the internal WebSocket handler.\r\n             *\r\n             * @memberof qz.api\r\n             */\r\n            setWebSocketType: function(ws) {\r\n                _qz.tools.ws = ws;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Version of this JavaScript library\r\n         *\r\n         * @constant {string}\r\n         *\r\n         * @memberof qz\r\n         */\r\n        version: _qz.VERSION\r\n    };\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(qz);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = qz;\r\n        try {\r\n            var crypto = require('crypto');\r\n            qz.api.setSha256Type(function(data) {\r\n                return crypto.createHash('sha256').update(data).digest('hex');\r\n            });\r\n        }\r\n        catch(ignore) {}\r\n    } else {\r\n        window.qz = qz;\r\n    }\r\n})();\r\n",null]}